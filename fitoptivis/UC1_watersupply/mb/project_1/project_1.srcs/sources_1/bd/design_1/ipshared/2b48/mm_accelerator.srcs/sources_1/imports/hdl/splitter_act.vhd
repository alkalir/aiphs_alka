-- -------------------------------------------------------------------------------
-- This file has been automatically generated by the Caph compiler (version 2.8.4d)
-- from file main.cph, on 2018-11-06 at 12:24:20, by <unknown>
-- For more information, see : http://caph.univ-bpclermont.fr
-- -------------------------------------------------------------------------------

library ieee,caph;
use ieee.std_logic_1164.all;
use caph.core.all;
use caph.data_types.all;
use ieee.numeric_std.all;

entity splitter is
   port (
    in_data_empty: in std_logic;
    in_data: in std_logic_vector(31 downto 0);
    in_data_rd: out std_logic;
    out_data_0_full: in std_logic;
    out_data_0: out std_logic_vector(31 downto 0);
    out_data_0_wr: out std_logic;
    out_data_1_full: in std_logic;
    out_data_1: out std_logic_vector(31 downto 0);
    out_data_1_wr: out std_logic;
    clock: in std_logic;
    reset: in std_logic
    );
end splitter;

architecture FSM of splitter is
    type t_enum3 is (FWD0,FWD1);
    signal state : t_enum3;
    signal n_state : t_enum3;
    signal en_state : boolean;
begin
  comb: process(in_data, in_data_empty, out_data_0_full, out_data_1_full, state)
    variable p_data : signed(31 downto 0);
  begin
    -- in_data.rdy, state=FWD0, out_data_0.rdy / p_data=in_data, state:=FWD1, wr(out_data_0,p_data)
    if in_data_empty='0' and state=FWD0 and out_data_0_full='0' then
      p_data := from_std_logic_vector(in_data,32);
      in_data_rd <= '1';
      n_state <= FWD1;
      en_state <= true;
      out_data_0 <= std_logic_vector(p_data);
      out_data_0_wr <= '1';
      out_data_1 <= (others => 'X');
      out_data_1_wr <= '0';
    -- in_data.rdy, state=FWD1, out_data_1.rdy / p_data=in_data, state:=FWD0, wr(out_data_1,p_data)
    elsif in_data_empty='0' and state=FWD1 and out_data_1_full='0' then
      p_data := from_std_logic_vector(in_data,32);
      in_data_rd <= '1';
      n_state <= FWD0;
      en_state <= true;
      out_data_1 <= std_logic_vector(p_data);
      out_data_1_wr <= '1';
      out_data_0 <= (others => 'X');
      out_data_0_wr <= '0';
    else
      in_data_rd <= '0';
      out_data_0_wr <= '0';
      out_data_1_wr <= '0';
      out_data_0 <= (others => 'X');
      out_data_1 <= (others => 'X');
      en_state <= false;
      n_state <= state;
    end if;
  end process;
  seq: process(clock, reset)
  begin
    if (reset='0') then
      state <= FWD0;
    elsif rising_edge(clock) then
      if ( en_state ) then
        state <= n_state after 1 ns;
      end if;
    end if;
  end process;
end FSM;
